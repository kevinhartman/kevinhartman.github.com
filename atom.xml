<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[kevin hartman]]></title>
  <link href="http://kevinhartman.github.com/atom.xml" rel="self"/>
  <link href="http://kevinhartman.github.com/"/>
  <updated>2012-07-23T00:49:17-07:00</updated>
  <id>http://kevinhartman.github.com/</id>
  <author>
    <name><![CDATA[Kevin Hartman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Inheritance Through IPC Using AIDL in Android]]></title>
    <link href="http://kevinhartman.github.com/blog/2012/07/23/inheritance-through-ipc-using-aidl-in-android/"/>
    <updated>2012-07-23T00:16:00-07:00</updated>
    <id>http://kevinhartman.github.com/blog/2012/07/23/inheritance-through-ipc-using-aidl-in-android</id>
    <content type="html"><![CDATA[<p>First off, this is my first post on this blog! I&#8217;m excited to have a space where I can share interesting things!</p>

<p><b>As a preface</b>, recently I was developing an Android Service with the intent of exposing it to other Android Applications in the future- sort of a shared service that other developers could tap into without having a need to create something similar and waste the user&#8217;s resources. My first thought was to set up the interprocess communication (IPC) aspect through an Android Messenger.</p>

<p>This is usually a good approach: concurrency is handled for you, client applications don&#8217;t need your AIDL interface (in fact, their developers don&#8217;t even need to know that AIDL exists), and you avoid having to ensure that the AIDL interface that you <em>didn&#8217;t</em> write maintains backwards compatible when you make changes.</p>

<p>Unfortunately for my application, a Messenger wasn&#8217;t a very clean solution. What I&#8217;d wanted was to essentially be able to allow client applications to provide a particular strategy for the service to use to do its work, globally. For example: <i>serviceInterface.setStrategy(new SomeStrategy())</i>. The newly set strategy would be used by the service (if it were more active than the current strategy, in my case), until another application changed it. This is ideal for the type of service I&#8217;m developing.</p>

<p><b>Why&#8217;s that?</b> Well, if I were to use a Messenger, every time I decided to add a new strategy to my service&#8217;s repertoire, I would need to add a new constant that would represent the act of setting that particular strategy, throw it into an ever-growing case statement within the message handler, and worst of all, if strategies required different initilizations, I&#8217;d have to read these from the message&#8217;s bundle and <em>hope</em> that the client application&#8217;s developer had provided bundle data with matching keys, values in the right format, or even remembered that the strategy depended on any data at all. That&#8217;s not clean. At all.</p>

<p>With a strategy pattern paired with the AIDL approach, this is much cleaner. The compiler will ensure that particular strategies are being constructed with the minimum amount of information that they require, and the interface that will be exposed to client application developers will be the &#8220;java way&#8221;- not at all any of that Messenger crap.</p>
]]></content>
  </entry>
  
</feed>
